<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OCR-ASR基础：CTC解读</title>
    <link href="/2021/12/07/ocr-ctc/"/>
    <url>/2021/12/07/ocr-ctc/</url>
    
    <content type="html"><![CDATA[<p>CTC主要用在文字识别、语音识别的最后一个环节，用于标签对齐。使用CTC的最终目的是得到梯度值，用来更新网络的参数。</p><p>$S$​​​​为定义在$D_{\chi \times \Zeta}$​​​​分布的训练数据，输入空间$\chi=(\mathbb R^m)^<em>$​​​​为$m$​​​​维向量，目标空间$\Zeta =L^</em>$​​​​是定义在有限字符$L$​​​​上的集合。$S: (x,z)$​​​​. $x$​​​​为输入，$z$​​​​为输出，在ctc中就是标记的字符序列。</p><p>目的就是训练分类器，$\chi \rightarrow \Zeta $的映射，使得输出的字符和标签的错误最小。</p><p>原始图片经过CNN处理后，转换为$m\times T$​​​的序列,即长度为$T$​​​的输入序列$\pmb x$​​​。假设经过RNN（LSTM）网络$N_w[(\mathbb R^m)^T \rightarrow (\mathbb R^n)^T]$​​​处理后，输出为$\pmb y$​​​，$y_k^t$​​​表示在时间$t$​​​时，RNN网络第$k$​​​个输出单元的值。在这里表示为$t$​​​时刻第$k$​​​个字符标签$l_k$​​​​​​的概率（经过softmax处理）。</p><script type="math/tex; mode=display">\pmb x=(\vec x^1,\vec x^2,\cdots,\vec x^T)\\\vec x^t=(x_1^t,x_2^t,\cdots,x_m^t)'\\\pmb y=(\vec y^1,\vec y^2,\cdots,\vec y^T)$\\\vec y^t=(y_1^t,y_2^t,\cdots,y_n^t)'</script><p><img src="/img/lstm.png" alt=""></p><script type="math/tex; mode=display">L'=L \cup \{blank\}\\p(\pi|x)=\prod_{t=1}^Ty_{\pi_t}^{t}, \forall \pi \in L'^T \tag{1.1}</script><p>$\pi$​表示输出字符串，上面的公式的意思是假设每个字符的输出概率时独立的，那么整个字符串的概率就是每个字符概率的乘积。</p><p>($\pi<em>t$​表示第$t$​个时刻，softmax处理后的得到的标签字符。假设标签的集合${a,b,c}$​，$t=1$​时，BiLSTM输出为${0.2,0.3,0.5}$​，此时输出$c$​的概率最大，所以$\pi_1=c$​，$y</em>{\pi_1}^{1}=0.5$​)</p><p>定义多对一的变换$\Beta：L’^T\rightarrow L^T$，主要是用于去除多余的空格和重复的字符。例如$\Beta(a-ab-)=\Beta(-aa—abb)=aab$</p><p>那么经过上述过程处理后，对于字符串$l$​​的输出概率为</p><script type="math/tex; mode=display">p(l|x)=\sum_{\pi\in \Beta^{-1}(l)}p(\pi|x)</script><p>上面的意思是，字符串$l$的输出概率时所有经过$B$变换后为$l$的字符串概率之和。</p><p>那么最终，我们只要找到最大概率的字符串作为输出即可，即</p><script type="math/tex; mode=display">h(x)=\text{arg max} \quad p(l|x)</script><p>对于长度为$r$的序列$\pmb q$，前$p$和后$p$个字符序列表示为$\pmb q<em>{1:p}$、$\pmb q</em>{r-p:r}$，其对应的标签序列为$\pmb l$.</p><p>对于任意输出序列$\pi$​，其前$t$​时刻经过$B$​变换后得到的字符序列为$l<em>{1:s}$​，即$B(\pi</em>{1:t})=\pmb l_{1:s}$​</p><p>则得到此字符序列的概率为</p><script type="math/tex; mode=display">\alpha_{t}(s) \stackrel{\text { def }}{=} \sum_{\mathcal{B}\left(\pi_{1: t}\right)={\pmb{l}}_{1: s}} \prod_{t^{\prime}=1}^{t} y_{\pi_{t^{\prime}}}^{t^{\prime}}</script><p>为了能够在输出中得到空格($blank$)，在$\pmb l$的两端和相邻字符中间插入$blank$，得到长度为$2|\pmb l|+1$的标签序列$\pmb l’$</p><p>当$t=1$时，要么路径节点处于$blank$，要么处于$l$的第一个字符。即</p><script type="math/tex; mode=display">\alpha_{1}(1)=y_{b}^{1}\\\alpha_{1}(2)=y_{1_{1}}^{1}\\\alpha_{1}(s)=0, \quad \forall s>2</script><p>另外，$\alpha<em>{t}(s)$​可以用$\alpha</em>{t-1}(s)$​、$\alpha<em>{t-1}(s-1)$​、$\alpha</em>{t-1}(s-2)$​表示</p><script type="math/tex; mode=display">\alpha_{t}(s)=\left\{\begin{array}{lr}(\alpha_{t-1}(s)+\alpha_{t-1}(s-1)) y_{l_{s}^{\prime}}^{t} & \text { if } l_{s}^{\prime}=b \text { or } l_{s-2}^{\prime}=l_{s}^{\prime} \\\left(\alpha_{t-1}(s)+\alpha_{t-1}(s-1)+\alpha_{t-1}(s-2)\right) y_{l_{s}^{\prime}}^{t} & \text { otherwise }\end{array}\right.</script><p><img src="/img/forward.png" alt=""></p><p>$\alpha_{t}(s)=0, \forall s&lt;\left|\mathbf{l}^{\prime}\right|-2(T-t)-1$​</p><p>因为一个时间跨度最多只能跨越两个字符，如果每时刻都跨越两个字符，则在$T-t$时间跨度内，最多能走$2(T-t)$个字符，如果剩余的字符个数$\left|\mathbf{l^{\prime}}\right|- s$​大于这个数目，则最终在$T$时刻不能到达字符尾端，所以在这种情况下前向概率为0</p><script type="math/tex; mode=display">p(\mathbf{l} \mid \mathbf{x})=\alpha_{T}\left(\left|\mathbf{l}^{\prime}\right|\right)+\alpha_{T}\left(\left|\mathbf{l}^{\prime}\right|-1\right)</script><p>最终字符串标签的输出概率就是以$blank$结尾的前向概率与非$blank$​结尾的前向概率之和。</p><p>同样可以定义后向概率。</p><script type="math/tex; mode=display">\beta_{t}(s) \stackrel{\text { def }}{=} \sum_{\mathcal{B}\left(\pi_{t: T}\right)=1_{s:|\pmb l|}} \prod_{t^{\prime}=t}^{T} y_{\pi_{t^{\prime}}}^{t^{\prime}}</script><script type="math/tex; mode=display">\begin{aligned}\beta_{T}\left(\left|\pmb l^{\prime}\right|\right) &=y_{b}^{T} \\\beta_{T}\left(\left|\pmb l^{\prime}\right|-1\right) &=y_{\pmb l_{|\pmb l|}}^{T} \\\beta_{T}(s) &=0, \forall s<\left|\pmb l^{\prime}\right|-1\end{aligned}</script><script type="math/tex; mode=display">\beta_{t}(s)= \begin{cases}(\beta_{t+1}(s)+\beta_{t+1}(s+1)) y_{l_{s}^{\prime}}^{t} & \text { if } l_{s}^{\prime}=b \text { or } l_{s+2}^{\prime}=l_{s}^{\prime} \\ \left(\beta_{t+1}(s)+\beta_{t+1}(s+1)+\beta_{t+1}(s+2)\right) y_{l_{s}^{\prime}}^{t} & \text { otherwise }\end{cases}</script><p><img src="/img/backward.png" alt=""></p><p>$\beta_{t}(s)=0,\forall s&gt;2 t$​</p><p>在$t$时间跨度内，最多走$2t$个字符，当前字符不可能走到$2t$之后的字符，所以后向概率为0。</p><p>对于输入$(x,z)$​，目标函数为极小化</p><script type="math/tex; mode=display">O^{M L}\left(S, \mathcal{N}_{w}\right)=-\sum_{(\mathbf{x}, \mathbf{z}) \in S} \ln (p(\mathbf{z} \mid \mathbf{x}))</script><p>为了使用梯度下降法进行优化求解，求关于每个分量的梯度</p><script type="math/tex; mode=display">\frac{\partial O^{M L}\left(\{(\mathbf{x}, \mathbf{z})\}, \mathcal{N}_{w}\right)}{\partial y_{k}^{t}}=-\frac{\partial \ln (p(\mathbf{z} \mid \mathbf{x}))}{\partial y_{k}^{t}}</script><p>下面考虑前向和后向概率的乘积</p><p>根据定义</p><script type="math/tex; mode=display">\alpha_{t}(s) \beta_{t}(s)=\sum_{\pi \in \mathcal{B}^{-1}(1): \atop \pi_{t}=l_{s}} y_{l_{s}}^{t} \prod_{t=1}^{T} y_{\pi_{t}}^{t}</script><p>所以</p><script type="math/tex; mode=display">\frac{\alpha_{t}(s) \beta_{t}(s)}{y_{l_{s}}^{t}}=\sum_{\pi \in \mathcal{B}^{-1}(1): \atop \pi_{t}=l_{s}} p(\pi \mid \mathbf{x})</script><p>即在$t$时刻，路径到达$l_s$的前向概率与$t$时刻到达$l_s$、$T-t$走完全程的后向概率乘积，再处于$t$时刻输出字符为$l_s$的概率，等于所有在$t$时刻经过$l_s$的字符序列路径之和。</p><p>所以</p><script type="math/tex; mode=display">p(\mathbf{l} \mid \mathbf{x})=\sum_{t=1}^{T} \sum_{s=1}^{|\mathbf{l}|} \frac{\alpha_{t}(s) \beta_{t}(s)}{y_{l_{s}}^{t}} \tag{1.2}</script><p>里面的求和表示在$t$时刻经过所有可能的字符概率之和，外面的对时间求和，表示整个标签字符串。</p><p>在这里，$l$和$z$是等价的，那么自然地，梯度就能够求出来，问题也就解决了。</p><p>流程梳理</p><p>假设现在我们要训练识别英文26个小写字母的模型，则</p><script type="math/tex; mode=display">L=\{a,b,c,\cdots,x,y,z\} \\L'=\{a,b,c,\cdots,x,y,z,-\}</script><p>$-$代表空白字符$blank$​​​</p><p><img src="/img/label.png" alt=""></p><p>如果我们要识别上面图的文字，标签为字符串$l=z=\text {label}$​​，假设图片的尺寸为$100 \times 32 \times 3$​​（RGB三个通道）,经过CNN转换成尺寸为$512 \times 25 \times 1$​​的图层，经过RNN层并softmax处理后，最终得到的输出尺寸为$27\times 25$​​的数组$\pmb y$​​。$25$​​为时间长度$T$​​，$27$​​代表$L’$​​​的元素个数。</p><p>那么</p><script type="math/tex; mode=display">\pmb y=(\vec y^1,\vec y^2,\cdots,\vec y^{25})\\\vec y^i=(p^i_a,p^i_b,\cdots,p^i_z, p^{i}_-)</script><p>$\vec y^i$每个分量表示属于对应的字母的概率，也即公式(1.1)中对应的$y_{\pi_t}^{t}$，并且所有分量的概率之和为1。</p><p>对于标签字符串$\text {label}$，$l’=\text{-l-a-b-e-l-}$，首先$\alpha<em>{1}(1)=y</em>{-}^{1},\alpha<em>{1}(2)=y</em>{l}^{1}$，也就是第一个字符为空白字符的概率，根据前向概率公式，可以依次推出任意的$\alpha_{t}(s)$，后向概率也同样如此。那么根据公式(1.2)就能够得到$p(\mathbf{l} \mid \mathbf{x})\stackrel{\text { def }}{=}p(\textNaN|\mid \mathbf{x})$​的概率，这样就可以算得梯度，能够用于更新网络。</p><p>RNN输入输出</p><p>[batch_size, time_steps, input_dims]</p><p>如</p><script type="math/tex; mode=display">\left[\begin{matrix}[[X_1^1,X_2^1,X_3^1] & [X_1^2,X_2^2,X_3^2]& [X_1^3,X_2^3,X_3^3] & [X_1^4,X_2^4,X_3^4]]\\[[Y_1^1,Y_2^1,Y_3^1] & [Y_1^2,Y_2^2,Y_3^2]& [Y_1^3,Y_2^3,Y_3^3] & [Y_1^4,Y_2^4,Y_3^4]]\\[[Z_1^1,Z_2^1,Z_3^1] & [Z_1^2,Z_2^2,Z_3^2]& [Z_1^3,Z_2^3,Z_3^3] & [Z_1^4,Z_2^4,Z_3^4]]\\[[U_1^1,U_1^2,U_1^3] & [U_1^1,U_1^2,U_1^3]& [U_1^1,U_1^2,U_1^3] & [U_1^1,U_1^2U_1^3]]\end{matrix}\right]</script><p>时间步长为4</p><p>输入维度为3</p><p>如果batch_size为2</p><p>第一个batch：</p><script type="math/tex; mode=display">\begin{matrix}[[X_1^1,X_2^1,X_3^1] & [X_1^2,X_2^2,X_3^2]& [X_1^3,X_2^3,X_3^3] & [X_1^4,X_2^4,X_3^4]]\\[[Y_1^1,Y_2^1,Y_3^1] & [Y_1^2,Y_2^2,Y_3^2]& [Y_1^3,Y_2^3,Y_3^3] & [Y_1^4,Y_2^4,Y_3^4]]\end{matrix}</script><p>Reference</p><p><a href="https://zhuanlan.zhihu.com/p/43534801">一文读懂CRNN+CTC文字识别</a></p><p>Paper</p><p><a href="https://mediatum.ub.tum.de/doc/1292048/file.pdf">Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>论文解读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卷积层、池化层图解</title>
    <link href="/2021/12/04/convolution_layer/"/>
    <url>/2021/12/04/convolution_layer/</url>
    
    <content type="html"><![CDATA[<p>详细说明卷积层和池化层的计算过程</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><ol><li><p>Stride</p><p><img src="/img/conv-stride.png" alt=""></p></li><li><p>Padding</p><p><img src="/img/conv-padding.png" alt=""></p></li><li><p>卷积核参数个数</p><p><img src="/img/conv-kernels.png" alt=""></p></li></ol><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p><img src="/img/maxpooling.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>深度学习算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django框架学习</title>
    <link href="/2021/12/03/django-01/"/>
    <url>/2021/12/03/django-01/</url>
    
    <content type="html"><![CDATA[<ul><li><p>装饰器</p><ul><li><p><code>functools.wraps</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorators</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrappers</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;this is wrappers docs.&quot;&quot;&quot;</span><br>        func(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> wrappers<br><br><span class="hljs-meta">@decorators</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;this is func docs.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br>f = func()<br><span class="hljs-comment"># func, if no @wraps, will be `wrappers`</span><br>f.__name__<br><span class="hljs-comment"># this is func docs. if no @ wraps, will be `this is wrappers docs.`</span><br>f.__doc__<br></code></pre></td></tr></table></figure></li><li><p>装饰器主要用处，在原代码的基础上添加新功能，而不需要改动原代码。应用举例：后台日志，授权</p></li></ul></li><li><p>Session</p><p>Cookies和Session</p><ul><li>当客户端首次访问服务端时，服务端会创建会话对象，并为该对象生成JsessionID，并将该信息包装成Cookies发送给客户端（浏览器），客户端会将该信息保存在本地。当客户端再次发送请求时，将本地的Cookies放入Request Headers中，发送给服务端，服务端解析Cookies，比对JsessionID，找到相应的会话对象，为之服务。</li></ul></li><li><p>Authentication</p></li></ul><ul><li><p>RSF 分页器</p><p>可以重写<code>PageNumberPagination</code>类的<code>get_paginated_response()</code>方法，并在setting.py中<code>RESTFRAME_WORK</code>模块添加了默认分页调用</p></li></ul><ul><li><p>send_mail</p><p>django自带send_mail，如果要使用第三方邮件（如网易），可以在第三方获得授权码，并将授权码放入setting.py的EMAIL_HOST_PASSWORD配置中。</p></li></ul><ul><li><p>Mixin</p><p>中文翻译为混入，主要用在多继承中。如果继承时单一继承，那么子类的父类是清晰的，但如果涉及到多继承，父类就是模糊的。Mixin也是多继承，但如果声明为Mixin，则表明该类是作为功能添加到继承条线中的，而不是作为父类继承的。</p></li></ul><ul><li><p>Model</p><ul><li><p>当字段设置为<code>ForeignKey</code>时，会在字段后自动添加_id来创建数据库表中的列名</p></li><li><p>自动添加<code>id</code>字段</p></li><li><p><code>ManyToManyField</code>为多对多的关系，如老师和学生，一个老师可以教多个学生，一个学生可以被多个老师教。在Django中，使用多对多的映射关系，会自动创建新表，表中有两个字段，分别是两张表的id。例如，创建Teacher表，在Student中设置mentor为多对多映射，则teacher字段不会再Student表中，而是会生成新表mentor_Student，并分别有student_id和teacher_id。</p></li><li><p>blank和null区别</p><ul><li><code>blank=True, null=True</code>：允许插入数据时该字段为空</li><li><code>blank=False, null=False</code>：插入数据时该字段不为空</li><li><code>blank=False, null=True</code>：在网页表单上插入数据时，该字段不能为空，但在通过<code>save()</code>、shell等非表单形式保存数据时，允许为空</li><li><code>blank=True, null=False</code>：不希望用户在表单中创建，而是通过在save方法中根据其他字段生成</li></ul><p>当出现第四种设置时，并不总会报错，因为在处理某些在数据库中实际的存储值为字符串的Field时，会默认转换为””</p></li><li><p>正向查询和反向查询（OneToOneField, ForeignKey参数（on_delete, related_name, to_field)</p><ul><li><p><code>objects.get()</code>返回的时Model类型、<code>objects.filter()</code> 、 <code>objects.all()</code>返回的是QuerySet类型</p></li><li><p>外键正向查询（A表有外键fk指向B表(字段有a,b,c,d)，通过A表查询B表）</p><ol><li>A.object.values(“fk__a”)</li><li>A.ojects.get(condition).fk.a</li></ol></li><li><p>外键反向查询（同上，通过B表查询A表）</p><p>如果外键没有设置related_name</p><ol><li>B.objects.get(condition).a_set.all()</li></ol><p><em>带外键的表名_set</em></p><p>如果外键设置related_name，假设为foreign</p><ol><li>B.objects.get(condition).foreign.all()</li></ol></li><li><p>OneToOneField、ManytoOneField(ForeignKey)、ManyToManyField</p><ul><li><p>外键和多对多的外键查询方式（正向和反向）是一样的，一对一查询正向和反向都是一样的方式，举例：</p><p>A有一对一字段a（指向C），一般字段b， C有字段d,e</p><p>A.objects.get(condition).c.d</p><p>C.objects.get(condition).a.b</p></li></ul></li></ul></li></ul></li></ul><ul><li><p>Backend</p><p>用于用户登录的密码验证</p></li><li><p>Serializer</p><p>序列化，主要用处是将后端数据库里的字段，通过model转换为模型对象（orm），serilzers则负责将模型对象转换为json、xml等通用格式。如果不适用序列化，则需要将模型对象进行强制类型转换，再编码为json格式，如果涉及外键，则需要进行拼接再转换类型并编码，非常麻烦。</p><p>SerializerMethodField(method<em>name=None)<br>method_name - 要调用的序列化程序上方法的名称。如果不包含此默认值get</em><field_name>。</p></li><li><p>Django接口自动化———-drf_yasg</p><ol><li><p>安装依赖包</p></li><li><p>接口改造</p><ul><li>url.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> permissions<br><span class="hljs-keyword">from</span> drf_yasg.views <span class="hljs-keyword">import</span> get_schema_view<br><span class="hljs-keyword">from</span> drf_yasg <span class="hljs-keyword">import</span> openapi<br><br>schema_view = get_schema_view(<br>   openapi.Info(<br>      title=<span class="hljs-string">&quot;Snippets API&quot;</span>,<br>      default_version=<span class="hljs-string">&#x27;v1&#x27;</span>,<br>      description=<span class="hljs-string">&quot;Test description&quot;</span>,<br>      contact=openapi.Contact(email=<span class="hljs-string">&quot;contact@snippets.local&quot;</span>),<br>      license=openapi.License(name=<span class="hljs-string">&quot;BSD License&quot;</span>),<br>   ),<br>   public=<span class="hljs-literal">True</span>,<br>   permission_classes=(permissions.AllowAny,),<br>)<br><br>urlpatterns += [<br>   url(<span class="hljs-string">r&#x27;^swagger(?P&lt;format&gt;\.json|\.yaml)$&#x27;</span>, schema_view.without_ui(cache_timeout=<span class="hljs-number">0</span>), name=<span class="hljs-string">&#x27;schema-json&#x27;</span>),<br>   url(<span class="hljs-string">r&#x27;^swagger/$&#x27;</span>, schema_view.with_ui(<span class="hljs-string">&#x27;swagger&#x27;</span>, cache_timeout=<span class="hljs-number">0</span>), name=<span class="hljs-string">&#x27;schema-swagger-ui&#x27;</span>),<br>   url(<span class="hljs-string">r&#x27;^redoc/$&#x27;</span>, schema_view.with_ui(<span class="hljs-string">&#x27;redoc&#x27;</span>, cache_timeout=<span class="hljs-number">0</span>), name=<span class="hljs-string">&#x27;schema-redoc&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><ul><li>view.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> drf_yasg.utils <span class="hljs-keyword">import</span> swagger_auto_schema, swagger_serializer_method<br><span class="hljs-keyword">from</span> drf_yasg <span class="hljs-keyword">import</span> openapi<br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">CBV试图，在get post put delete前加此代码</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>questionview_post_parm = openapi.Schema(<span class="hljs-built_in">type</span>=openapi.TYPE_OBJECT,<br>                                    properties=&#123;<br>                                        <span class="hljs-string">&#x27;pk&#x27;</span>: openapi.Schema(description=<span class="hljs-string">&#x27;待更新问题的编号&#x27;</span>,<br>                                                                <span class="hljs-built_in">type</span>=openapi.TYPE_INTEGER,),<br>                                        &#125;,<br>                                    )<br>questionview_post_response = &#123;<span class="hljs-number">200</span>: openapi.Response(description=<span class="hljs-string">&#x27;添加成功&#x27;</span>, <br>                                                    examples=&#123;<span class="hljs-string">&#x27;json&#x27;</span>: &#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;问题添加成功&#x27;</span>&#125;<br>                                                                &#125;<br>                                                    )<br>                                &#125;<br><br><span class="hljs-meta">@swagger_auto_schema(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-meta">                    operation_description=<span class="hljs-string">&#x27;cud/(?P&lt;pk&gt;\d+)/&#x27;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">                    operation_summary=<span class="hljs-string">&quot;上传问题库或插入单条问题&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">                    manual_parameters=[</span></span><br><span class="hljs-params"><span class="hljs-meta">                        openapi.Parameter(<span class="hljs-params"><span class="hljs-string">&#x27;question&#x27;</span>, openapi.IN_QUERY, description=<span class="hljs-string">&#x27;问题&#x27;</span>, <span class="hljs-built_in">type</span>=openapi.TYPE_STRING</span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">                        openapi.Parameter(<span class="hljs-params"><span class="hljs-string">&#x27;catagory_id&#x27;</span>, openapi.IN_QUERY, description=<span class="hljs-string">&#x27;问题类别&#x27;</span>, <span class="hljs-built_in">type</span>=openapi.TYPE_STRING</span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">                        openapi.Parameter(<span class="hljs-params"><span class="hljs-string">&#x27;answer&#x27;</span>, openapi.IN_QUERY, description=<span class="hljs-string">&#x27;回答&#x27;</span>, <span class="hljs-built_in">type</span>=openapi.TYPE_STRING</span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">                        openapi.Parameter(<span class="hljs-params"><span class="hljs-string">&#x27;file&#x27;</span>, openapi.IN_QUERY, description=<span class="hljs-string">&#x27;excel形式问题库&#x27;</span>, <span class="hljs-built_in">type</span>=openapi.TYPE_FILE</span>),],</span></span><br><span class="hljs-params"><span class="hljs-meta">                    request_body=questionview_post_parm,</span></span><br><span class="hljs-params"><span class="hljs-meta">                    responses=questionview_post_response</span>)</span><br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">openapi.IN_HEADER，openapi.IN_QUERY可以参考官方文档 https://drf-yasg.readthedocs.io/en/stable/index.html</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>USER_AUTH = [openapi.Parameter(<span class="hljs-string">&#x27;Authorization&#x27;</span>, <br>                               openapi.IN_HEADER, <br>                               description=<span class="hljs-string">&#x27;用户cookies信息&#x27;</span>, <br>                               <span class="hljs-built_in">type</span>=openapi.TYPE_STRING,<br>                               required=<span class="hljs-literal">True</span>)]<br><span class="hljs-meta">@swagger_auto_schema(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-meta">    operation_description=<span class="hljs-string">&quot;/question/collection&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">    operation_summary=<span class="hljs-string">&quot;用户收藏查询&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">    manual_parameters=[</span></span><br><span class="hljs-params"><span class="hljs-meta">        openapi.Parameter(<span class="hljs-params"><span class="hljs-string">&#x27;more&#x27;</span>, </span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-meta">                            openapi.IN_QUERY,</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-meta">                            description=<span class="hljs-string">&#x27;显示多于五条记录&#x27;</span>,</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-meta">                            <span class="hljs-built_in">type</span>=openapi.TYPE_BOOLEAN</span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        USER_AUTH[<span class="hljs-number">0</span>]</span></span><br><span class="hljs-params"><span class="hljs-meta">        ]</span></span><br><span class="hljs-params"><span class="hljs-meta"></span>)</span><br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">FBV， method=&#x27;get&#x27; &#x27;post&#x27;, &#x27;put&#x27;, &#x27;delete&#x27;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>search_questions_get_parm = openapi.Schema(<span class="hljs-built_in">type</span>=openapi.TYPE_OBJECT,<br>                                       properties=&#123;<br>                                           <span class="hljs-string">&#x27;keyword&#x27;</span>: openapi.Schema(description=<span class="hljs-string">&#x27;提问的问题&#x27;</span>,<br>                                                                     <span class="hljs-built_in">type</span>=openapi.TYPE_STRING,),<br>                                           &#125;,<br>                                       )<br>search_questions_get_response = &#123;<span class="hljs-number">200</span>: openapi.Response(description=<span class="hljs-string">&#x27;response&#x27;</span>, <br>                                                       examples=&#123;<span class="hljs-string">&#x27;json&#x27;</span>: &#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;发送成功&quot;</span>&#125;<br>                                                                 &#125;<br>                                                       )<br>                                 &#125;<br><span class="hljs-meta">@swagger_auto_schema(<span class="hljs-params">method=<span class="hljs-string">&#x27;get&#x27;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">                     operation_description=<span class="hljs-string">&#x27;/question/search_questions/&#x27;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">                     operation_summary=<span class="hljs-string">&quot;问题提问(仅更新热门问题数据库)&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">                     <span class="hljs-comment"># request_body=search_questions_get_parm,</span></span></span><br><span class="hljs-params"><span class="hljs-meta">                     responses=search_questions_get_response</span>)</span><br></code></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCR识别算法(二) 文字识别</title>
    <link href="/2021/12/03/ocr-02/"/>
    <url>/2021/12/03/ocr-02/</url>
    
    <content type="html"><![CDATA[<h2 id="crnn-ctc识别"><a href="#crnn-ctc识别" class="headerlink" title="crnn+ctc识别"></a>crnn+ctc识别</h2><p>在标签处理上，将<code>char_std_5990.txt</code>的文字转换为字典，<code>key</code>为序号，<code>value</code>为汉字。每张图片上的文字已经给定了，使用上面的字典做映射，将文字序列映射为数字序列。在模型训练时，对于每张图片，转换成称灰度图片（<code>convert(&#39;L&#39;)</code>)，再经过尺寸变换，作为网络的输入，则输入值的标签为文字映射的数字序列。</p><p>即图片像素值———&gt; 数字序列的映射，预测时，将数字序列反向映射为文字即可。</p><h3 id="CRNN-CNN-RNN"><a href="#CRNN-CNN-RNN" class="headerlink" title="CRNN(CNN+RNN)"></a>CRNN(CNN+RNN)</h3><ul><li><h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>使用<code>VGG16</code>的微调结构</p><p><img src="https://img-blog.csdnimg.cn/20190326174838218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW9oZW5nMTk5Mg==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p>为了防止梯度消失，使用<code>LSTM</code>结构单元</p><h3 id="CTC"><a href="#CTC" class="headerlink" title="CTC"></a>CTC</h3><p>针对<code>Seq2Seq</code>预测存在的问题，主要是预测字符中有重复字符、空字符等，<code>CTC</code>主要解决的是处理这些无效字符。</p></li></ul><p>整个网络的训练数据，首先是将标签（汉字）根据标准字符库映射为数字数字序列表示，损失函数采用<code>CTC</code>损失。</p><p>保存的模型是不包含<code>CTC</code>的模型参数，在预测时，再根据数字解码为汉字。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OCR</tag>
      
      <tag>CRNN</tag>
      
      <tag>CTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCR识别算法(一) 文字定位</title>
    <link href="/2021/12/03/ocr-01/"/>
    <url>/2021/12/03/ocr-01/</url>
    
    <content type="html"><![CDATA[<h3 id="AdvancedEAST"><a href="#AdvancedEAST" class="headerlink" title="AdvancedEAST"></a><strong>AdvancedEAST</strong></h3><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">c = \pm\sqrt{a^2 + b^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.12661100000000003em;"></span><span class="mord">±</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.913389em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.873389em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12661100000000003em;"><span></span></span></span></span></span></span></span></span><p>AdvancedEAST是文字定位的经典模型，网络结构主体为VGG16，在本文中，重点关图像数据处理、损失函数和网络输出处理等内容。</p><ul><li><p>网络结构</p><p><img src="/img/EAST网络结构说明.png" alt=""></p></li></ul><h2 id="图像预处理——preprocess-py"><a href="#图像预处理——preprocess-py" class="headerlink" title="图像预处理——preprocess.py"></a>图像预处理——preprocess.py</h2><ul><li><p>batch_reorder_vertexes</p><p>reorder_vetexes的批量处理</p></li><li><p>reorder_vertexes</p><p>在标签中，有每个文字条目的位置，该函数主要是重新对位置进行排序。以图片左上角为坐标原点，保证顺序如下图</p><p><img src="/img/rectan.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xy_list = np.array([[<span class="hljs-number">48.45</span>, <span class="hljs-number">231.83</span>], [<span class="hljs-number">17.87</span>, <span class="hljs-number">178.79</span>], [<span class="hljs-number">179.84</span>, <span class="hljs-number">11.1</span>], [<span class="hljs-number">228.79</span>, <span class="hljs-number">47.95</span>]])<br></code></pre></td></tr></table></figure><p>确定的算法为</p><ul><li>确定第1个位置。首先以$x$坐标最小为基准选取，$x$如果相等，选取$y$较小的为第1个位置；</li><li>确定第3个位置。求出剩余四个坐标与第0个坐标连线的斜率值，第二大的为第3个位置。</li><li>确定第2个和第4个位置。连线1和3确定斜率和截距，将剩余的两个点带入函数，大于0的是第4个位置，小于0的是第2个位置。</li><li>再次确定13和24的位置。以左上角为原点时，13的斜率是正的，24为负的，如果出现相反的情况，调整四个点的相对顺序即可。</li></ul></li><li><p>resize_image</p><p>根据配置文件调整图片的大小</p></li><li><p>preprocess</p><p>调整图片大小，确定顺序，缩减(label.py-shrink)边界，连线画框【有三个框，原始为绿色，缩减后为蓝色，缩减的区域为黄色】。如果缩减比例相同，黄色+蓝色应该与绿色区域覆盖相同，但在项目中，两者的缩减比例不同，所以黄色+蓝色与绿色的覆盖不相同。</p></li></ul><h2 id="标签处理——label-py"><a href="#标签处理——label-py" class="headerlink" title="标签处理——label.py"></a>标签处理——label.py</h2><ul><li><p>shrink</p><p>缩减框选区域，返回缩减后的位置，与长边的位置。</p></li></ul><p>计算1-2, 2-3, 3-4, 4-1四个点对之间的欧式距离，确定长边与短边。计算r（？），根据两个点之间的距离确定斜率的夹角度数（<em>theta</em>），分别缩减（shrink_edge）两条长边和两条短边。</p><ul><li><p>shrink_edge</p><p>缩减边框，以1-2点对为例，计算两者x之间的距离（距离*cos(<em>theta</em>)*缩减比例，这里应该也可以直接让两个点做差？），y之间的距离，按照缩减比例，对两个点进行变换</p></li><li><p>process_label</p><p>标签像素0-1化？缩减后的坐标点，定位x最小和最大，y最小和最大，用来定位包含选框的最大规则矩形范围。</p></li></ul><h3 id="网络输出处理——nms-py"><a href="#网络输出处理——nms-py" class="headerlink" title="网络输出处理——nms.py"></a>网络输出处理——nms.py</h3><ul><li><p>nms (Non-Maximum Suppression) 算法</p><p>目标检测中消除多余的（交叉）的窗口</p><p>参考链接：<a href="https://www.cnblogs.com/zf-blog/p/8532228.html">https://www.cnblogs.com/zf-blog/p/8532228.html</a></p></li></ul><p>  在AdvancedEAST中，nms算法不太相同，主要有以下步骤：</p><ul><li>将所有内部点的位置坐标聚类，聚类依据为是否为 集合内的所有点是否是连续的一条横线</li><li>将上述的集合再聚类，如果所有的线都是上下连续的区域，那么就是同一个类别</li><li>针对2中聚类的集合簇，判断簇中的坐标点对应的位置是否为边界区域，如果是，那么求出这个点的原始位置，再分别求出四个顶点的位置平均值，对应了最终四个顶点位置预测值</li><li>score为每个顶点的元素个数</li></ul><ul><li><p>should_merge</p><p>给定一个坐标点集合region，判断$(i, j)$​左边的点$(i, j - 1)$是否在集合内</p></li><li><p>region_neighbor</p><p>每个水平连续的点集，将之往下移动一个单位，再分别加上两端的相邻点</p><p><img src="/img/nms-02.png" alt=""></p></li><li><p>rec_region_merge</p><p>针对<code>nms</code>处理后的坐标点分类集合，判断每个点集的正下方是否与分类集合有重合，如果有，那么他们就属于一类，递归的处理这个类中的元素和剩下的集合。</p></li><li><p>region_group</p><p>针对所有坐标分类点集，使用<code>rec_region_merge</code>将所有的点集分成不同的类别，使分类后的效果等同于定位不同的文字框选区域。</p></li><li><p>nms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">region_list = []<br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(activation_pixels[<span class="hljs-number">0</span>], activation_pixels[<span class="hljs-number">1</span>]):<br>    merge = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(region_list)):<br>        <span class="hljs-keyword">if</span> should_merge(region_list[k], i, j):<br>            region_list[k].add((i, j))<br>            merge = <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># Fixme 重叠文本区域处理，存在和多个区域邻接的pixels，先都merge试试</span><br>            <span class="hljs-comment"># break</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> merge:<br>                region_list.append(&#123;(i, j)&#125;)<br></code></pre></td></tr></table></figure><p><code>activation_pixels</code>为坐标点集合，这段代码最终展现的效果是将所有坐标点按照是否水平相邻不间断连接分为不同的集合</p><p><img src="/img/nms-01.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">D = region_group(region_list)<br><span class="hljs-comment"># D = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11, 12]]</span><br><span class="hljs-comment"># D中的元素，为每个文字区域对应的region_list中set下标 probably</span><br>quad_list = np.zeros((<span class="hljs-built_in">len</span>(D), <span class="hljs-number">4</span>, <span class="hljs-number">2</span>))<br>score_list = np.zeros((<span class="hljs-built_in">len</span>(D), <span class="hljs-number">4</span>))<br><span class="hljs-keyword">for</span> group, g_th <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(D, <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(D))):<br>    total_score = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>))<br>    <span class="hljs-comment"># group = [0, 1, 2, 3]</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> group:<br>        <span class="hljs-comment"># row = 0</span><br>        <span class="hljs-keyword">for</span> ij <span class="hljs-keyword">in</span> region_list[row]:<br>            <span class="hljs-comment"># region_list[row], for example &#123;(0, 1), (0, 2), (0, 3), (0, 4)&#125;</span><br>            <span class="hljs-comment"># ij = (0, 1) ij为位置坐标</span><br>            score = predict[ij[<span class="hljs-number">0</span>], ij[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>] <span class="hljs-comment"># channel为1时，代表是否在边界区域</span><br>            <span class="hljs-keyword">if</span> score &gt;= threshold:<br>                ith_score = predict[ij[<span class="hljs-number">0</span>], ij[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">#</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (cfg.trunc_threshold &lt;= ith_score &lt; <span class="hljs-number">1</span> -<br>                        cfg.trunc_threshold):<br>                    ith = <span class="hljs-built_in">int</span>(np.around(ith_score)) <span class="hljs-comment"># ith = 0 左边，ith = 1， 右边</span><br>                    total_score[ith * <span class="hljs-number">2</span>:(ith + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>] += score<br>                    <span class="hljs-comment"># ith = 0, 填充 0 1位置</span><br>                    <span class="hljs-comment"># ith = 1, 填充 2 3位置</span><br>                    px = (ij[<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span>) * cfg.pixel_size<br>                    py = (ij[<span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span>) * cfg.pixel_size<br>                    p_v = [px, py] + np.reshape(predict[ij[<span class="hljs-number">0</span>], ij[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>:<span class="hljs-number">7</span>],<br>                                          (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>                    <span class="hljs-comment"># 回归原始位置</span><br>                    quad_list[g_th, ith * <span class="hljs-number">2</span>:(ith + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>] += score * p_v<br>    score_list[g_th] = total_score[:, <span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 理想情况下， score非0即1, 那么total_score中就是属于每个角的元素个数</span><br>    <span class="hljs-comment"># qual_list + pv,  再 / total_score 就是这些点的平均值，也就是寻找到了每个顶点的位置</span><br>    <span class="hljs-comment"># score 统计左边 和 右边边界区域元素个数</span><br>    quad_list[g_th] /= (total_score + cfg.epsilon)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OCR</tag>
      
      <tag>AdvancedEAST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两小题算法</title>
    <link href="/2021/11/09/leetcode-1/"/>
    <url>/2021/11/09/leetcode-1/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></li></ol><ul><li>序列化(serialize)，只需要使用前序遍历(preorder)算法对二叉树进行遍历即可</li><li>反序列化(deserialze)，需要将序列化即前序遍历的结果转化为二叉树结构，同样地，可以递归的构建树结构。这时候可以添加标记cnt，用来记录当前构建的树节点在前序遍历中的位置。值得注意的是，在递归中，每次的参数data是不变的，只有cnt在增加，通过cnt可以直接定位到当前节点的值。</li></ul><hr><ol><li><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></li></ol><ul><li>首先考虑没有重复字符的情况。排列组合问题一般的解题思路是使用递归实现回溯法，回溯比较好理解，分为“进入”与“退出”两部分，比如首先将某个元素添加到数组中，在最后需要将这个元素从数组中弹出。关键在于如何实现递归。</li><li>考虑递归的结束条件。这个相对比较容易，当某个排列的长度等于原字符串的长度时，将这条记录导出，同时函数返回。</li><li>考虑缩减规模。当遍历到某个元素时，下一步是递归的排列除了这个元素剩下的部分，在字符串中，将前面的部分和后面的部分合并，成为新字符串，实现了规模的缩减。</li><li>考虑如何实现全部的排列。（细节）每个元素的重要性都是一样的，因此对原始字符串中的每个元素都同时进行相应的处理。考虑使用循环，循环的总体是当前字符串（如上一段所说，每次这个字符串每次都是相对缩减的，因此最终会达到到结束的条件的。），对每个字符串做同样的处理。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span>(<span class="hljs-params">string, permute</span>):</span><br><span class="hljs-keyword">if</span> permute与原始string长度相等:<br>permute导出<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">for</span> idx, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(string):<br>permute与char合并<br><span class="hljs-comment"># 缩减规模</span><br>self.helper(string idx前部分+string idx+<span class="hljs-number">1</span>后部分, permute)<br>permute去掉char<br></code></pre></td></tr></table></figure></li><li>如果有重复元素，在导出时，使用set结构，去重</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
